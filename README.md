# cs-interview

# C++
### C++ STL 
1. unordered_map<int, int>mp c++中哈希表对应的容器    查找复杂度 o(1)

2. map<int, int> mp  底层红黑树实现 插入查找删除复杂度 logn， 插入n个元素就是nlogn

if(mp.find(key) != mp.end() ) 判断是否存在

---
### define 和 const区别
1. define在预处理阶段被替换
2. const在编译运行阶段被处理

### extern作用
1. 置于变量或函数前，表示定义在别的文件中，提示编译器遇到此变量或函数在其他文件中寻找定义。

### volatile
1. 强制cpu每次从内存中访问变量，因为寄存器有可能（被别的程序）改变。
2. 内存中的值发生变化，寄存器还没变

### 封装、继承、多态
* 接口的多种不同实现方式为多态
1. 使用虚函数才会调用子类同函数，运行时多态（动态多态，通过虚函数和继承关系，在运行时确定），使用上层操作来执行下层具体操作
2. 父类指针指向子类对象
3. 编译时多态（静态多态）：重载函数，模板技术

# 计网
客户端和服务器都可主动发起挥手动作，对应socket编程的close()，任何一方都可发起

连接动作对应connect()，对应三次握手，accept()从队列中取出连接

---
为什么三次握手而不是两次，A还要发送一次确认？
1. 防止已经失效的连接请求送到了B, A没有建立连接，B缺认为已建立连接，等待数据到来，浪费资源。
2. 同步双方序列号，确认号

# 操作系统
### cache（类比于停车位）
* 直接映射，每组只有一个cacheline,只用大cache。内存中某块只能映射到特定组
* 组相联映射，s组，每组e个cacheline
* 全相联映射，适用小容量cache，只有一个组

CPU的程序计数器和各种寄存器都只有一份，当进程切换时，就需要保存进程上下文

---
### Linux IO模式
1. 同步 
* 阻塞：等待
* 非阻塞：轮询查看

2. 异步
* 非阻塞：全部交给cpu/内核处理，只等待完成信号
---

* 同步/异步 针对程序和内核的交互
* 阻塞/非阻塞 关心单个进程的执行状态
---
io多路复用

1. select

* 效率O(n)，有事件发生，不知道哪几个流，需要轮询找出数据
* 大量数据拷贝，需要用户空间和内核空间拷贝fd数组
* 有最大连接数限制：1024

2. poll

* 没有最大连接限制，采用链表
* 其他缺点和select一样

3. epoll

* 复杂度O(1), 会把哪几个流发生了什么io时间通知，是事件驱动的
* 使用事件的就绪通知方式，通过epoll_ctl注册fd，一旦fd就绪，内核就用callback回调机制激活fd，epoll_wait收到通知

* 为什么会有ET？

1. 一旦有大量不需要读写的fd，每次epoll_wait都会返回，浪费资源
2. 比LT效率高，系统不会有大量不关心的就绪fd。

* epoll优点？
1. 没有最大并发限制
2. O(1),不是轮询方式。只有活跃可用的fd才会调用callback。只会管活跃的连接，和总连接数无关。即时上百万个总连接，同时活跃的连接数很少。所以效率和活跃的连接数有关。

当连接数少且都十分活跃是，select和poll可能会更高。

# 数据库
### B+树
1个索引节点就是1个磁盘页

m阶B+树，xx个关键字，xx个指针

1. 非叶子节点不保存关键字记录的指针，只进行数据索引，可保存更多的索引信息
（非叶节点不包含指向 数据记录 存放地址的指针，没有data域）
2. 叶子节点保存了父节点所有关键字记录的指针
3. 叶子节点间有指针相连，从小到大，方便进行范围查找

### 红黑树
1. 根节点是黑色的
2. 从跟到叶子的路径上黑色节点数相同
3. 保证最长路径不大于最短路径的2倍

# Linux
### 文件
1. 一个文件占用1个inode，记录文件属性，记录内容所在的block编号，一个文件会占用多个block
2. 磁盘锁片：文件所在block过于分散，block只能被1个文件使用
3. 文件名记录在目录中，目录的x属性可修改文件名