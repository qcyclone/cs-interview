# cs-interview

## C++
### C++ STL 
1. unordered_map<int, int>mp c++中哈希表对应的容器    查找复杂度 o(1)

2. map<int, int> mp  底层红黑树实现 插入查找删除复杂度 logn， 插入n个元素就是nlogn

if(mp.find(key) != mp.end() ) 判断是否存在

### define 和 const区别
1. define在预处理阶段被替换
2. const在编译运行阶段被处理

## 计网
客户端和服务器都可主动发起挥手动作，对应socket编程的close()，任何一方都可发起

连接动作对应connect()，对应三次握手，accept()从队列中取出连接

为什么三次握手而不是两次，A还要发送一次确认？

1. 防止已经失效的连接请求送到了B, A没有建立连接，B缺认为已建立连接，等待数据到来，浪费资源。
2. 同步双方序列号，确认号

## 操作系统
### cache
* 直接映射
* 组相联映射
* 全相联映射，适用小容量cache

CPU的程序计数器和各种寄存器都只有一份，当进程切换时，就需要保存进程上下文

---
### Linux IO模式
1. 同步 
* 阻塞：等待
* 非阻塞：轮询查看

2. 异步
* 非阻塞：全部交给cpu/内核处理，只等待完成信号
---

* 同步/异步 针对程序和内核的交互
* 阻塞/非阻塞 关心单个进程的执行状态
---
io多路复用

1. select

* 效率O(n)，有事件发生，不知道哪几个流，需要轮询找出数据
* 需要用户空间和内核空间拷贝fd数组
* 有最大连接数限制：1024

2. poll

* 没有最大连接限制，采用链表
* 其他缺点和select一样

3. epoll

* 复杂度O(1), 会把哪几个流发生了什么io时间通知，是事件驱动的
* 使用事件的就绪通知方式，通过epoll_ctl注册fd，一旦fd就绪，内核就用callback回调机制激活fd，epoll_wait收到通知

* 为什么会有ET？

1. 一旦有大量不需要读写的fd，每次epoll_wait都会返回，浪费资源
2. 比LT效率高，系统不会有大量不关心的就绪fd。

* epoll优点？
1. 没有最大并发限制
2. O(1),不是轮询方式。只有活跃可用的fd才会调用callback。只会管活跃的连接，和总连接数无关。即时上百万个总连接，同时活跃的连接数很少。所以效率和活跃的连接数有关。

当连接数少且都十分活跃是，select和poll可能会更可是。
